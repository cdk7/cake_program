#  4.1 The turtle module
# import turtle
# bob = turtle.Turtle()
# print(bob)
# # 4.2 simple repetitions.
# for i in range(4):
#     bob.fd(100)
#     bob.lt(90)
# bob.fd(100)
# mainloop tells window to wait for the user to do something.
# turtle.mainloop()

# 4.3 Exercises
# Write a function called square that takes a parameter named t, which is a turtle.
# It should use the turtle to draw a square.

# 4.3.1
import math
import turtle


# def square(t, length):
#     """Draws a square with sides of the given length.
#     Returns the Turtle to the starting position and location.
#     """
#     for i in range(4):
#         t.fd(length)
#         t.lt(90)
#
#
# print(square(turtle, 100))

# def polygon(t, length, n):
#     """Draws a square with sides of the given length.
#     Returns the Turtle to the starting position and location.
#     """
#     for i in range(n):
#         t.fd(length)
#         t.lt(360//n)
#     t.mainloop()
#
#
# print(polygon(turtle, 100, 6))

#
# def polyline(t, n, length, angle):
#     """Draws n line segments.
#     t: Turtle object
#     n: number of line segments
#     length: length of each segment
#     angle: degrees between segments
#     """
#     for i in range(n):
#         t.fd(length)
#         t.lt(angle)
#
#
# def polygon(t, n, length):
#     """Draws a polygon with n sides.
#     t: Turtle
#     n: number of sides
#     length: length of each side.
#     """
#     angle = 360.0/n
#     polyline(t, n, length, angle)
#
#
# def arc(t, r, angle):
#     """Draws an arc with the given radius and angle.
#     t: Turtle
#     r: radius
#     angle: angle subtended by the arc, in degrees
#     """
#     arc_length = 2 * math.pi * r * abs(angle) / 360
#     n = int(arc_length / 4) + 3
#     step_length = arc_length / n
#     step_angle = float(angle) / n
#
#     # making a slight left turn before starting reduces
#     # the error caused by the linear approximation of the arc
#     t.lt(step_angle/2)
#     polyline(t, n, step_length, step_angle)
#     t.rt(step_angle/2)
#
#
# def circle(t, r):
#     """Draws a circle with the given radius.
#     t: Turtle
#     r: radius
#     """
#     arc(t, r, 360)
#
#
# # the following condition checks whether we are
# # running as a script, in which case run the test code,
# # or being imported, in which case don't.
#
# if __name__ == '__main__':
#     bob = turtle.Turtle()
#
#     # draw a circle centered on the origin
#     radius = 100
#     bob.pu()
#     bob.fd(radius)
#     bob.lt(90)
#     bob.pd()
#     circle(bob, radius)
#
#     # wait for the user to close the window
#     turtle.mainloop()
#
#
# # # 4.4
# bob = turtle.Turtle()

#
# def square(t):
#     for i in range(4):
#         t.fd(100)
#         t.lt(90)


# square(bob)
#
# alice = turtle.Turtle()
# square(alice)


# def square(t, length):
#     for i in range(4):
#         t.fd(length)
#         t.lt(90)
#
#
# square(bob, 100)

#
# def polygon(t, n, length):
#     angele = 360/n
#     for i in range(n):
#         t.fd(length)
#         t.lt(360//n)
#
#
# print(polygon(bob, 7, 70))

#  Encapsulation: wrapping a piece of code up in a function
#
# def square(t):
#     for i in range(4):
#         t.fd(100)
#         t.lt(90)

# alice = turtle.Turtle()
# square(alice)


#  Generalization: add a parameter to a function
# It makes the function more general.

# def square(t, length, angle=90):
#     for i in range(4):
#         t.fd(length)
#         t.lt(angle)

def polyline(t, n, length, angle):
    for i in range(n):
        t.fd(length)
        t.lt(angle)


def polygon(t, n, length):
    angle = 360 / n
    polyline(t, n, length, angle)

# bob = turtle.Turtle()
# polygon(bob, 8, 80)

# Keyword arguments:
# This syntax makes the program more readable.
# It is also a reminder about how arguments and parameter works.
# polygon(bob, n=8, length=80)


# def circle(t, r):
#     # By convention, import statements are usually at the beginning of the script.
#     circumference = 2 * math.pi * r
#     # n is the number of line segments in our approximation of circle.
#     # length is the length of each segment.
#     """
#     Interface: A function generated by taking n as a parameter.
#     The number of segments is an integer near circumference / 3.
#     Add 3 to n guarantees that polygon has at least 3 sides.
#     """
#     n = int(circumference/3) + 3
#     length = circumference / n
#     polygon(t, n, length)
#
#
# alice = turtle.Turtle()
# circle(alice, 50)

# Refactoring


def arc(t, r, angle):
    arc_length = 2 * math.pi * r * angle/360
    n = int(arc_length/3) + 3
    step_length = arc_length/n
    step_angle = angle/n
    polyline(t, n, step_length, step_angle)


def circle(t, r):
    arc(t, r, 360)


alice = turtle.Turtle()
circle(alice, 200)

"""
A development plan
1. Start by writing a small program with no function definitions.
2. Once you get the program working, identify a coherent piece of it, 
            encapsulate the piece in a function and give it a name.
3. Generalize the function by adding appropriate parameters.
4. Repeat step 1-3 until you have a set of working functions. 
    Copy and paste working code to avoid retyping (and re-debugging)
5. Look for opportunities to improve the program by refactoring. 
    For example, if you have similar code in several places, 
    consider factoring it into an appropriately general function. 
"""

#  4.9 docstring  >>>> using """/""" to comment your function

#  5.0  debugging >>>>
#  preconditions: requirements of arguments, it is the responsibility of the caller.
#  If the caller violates a precondition and the function doesn't work correctly,
#  the bug is in the caller, not the function.

#  postconditions: conditions at the end of the function
#  If the preconditions are satisfied and the postconditions are not, the bug is in the function.
